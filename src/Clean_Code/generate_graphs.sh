#!/bin/bash

# Script to generate PyTorch Geometric graphs from embeddings
# This script processes embeddings generated by generate_gnn_embeddings.sh

# Default values
DATASET_NAME="setfit/ag_news"
# The embeddings are stored in a nested structure with the dataset name repeated
EMBEDDINGS_DIR="/app/src/Clean_Code/output/embeddings/setfit/ag_news"
BATCH_SIZE=200  # Reduced batch size for better memory management
EDGE_TYPE="constituency"
LABEL_SOURCE="llm"  # Can be 'original' or 'llm'

# Function to display help message
show_help() {
    echo "Usage: $(basename $0) [options]"
    echo ""
    echo "Options:"
    echo "  --dataset_name NAME      Dataset name (e.g., stanfordnlp/sst2, setfit/ag_news) [default: stanfordnlp/sst2]"
    echo "  --embeddings_dir DIR     Directory containing embeddings [default: /app/src/Clean_Code/output/embeddings/stanfordnlp/sst2]"
    echo "  --batch_size N           Batch size for graph processing (default: 10)"
    echo "  --edge_type TYPE         Type of edges to create (constituency) (default: constituency)"
    echo "  --label_source SOURCE    Source of labels to use: 'original' or 'llm' (default: original)"
    echo "                           'original': Use original dataset labels"
    echo "                           'llm': Use LLM predictions as labels"
    echo "  --help                   Show this help message"
    echo ""
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        --dataset_name)
            DATASET_NAME="$2"
            shift
            shift
            ;;
        --embeddings_dir)
            EMBEDDINGS_DIR="$2"
            shift
            shift
            ;;
        --batch_size)
            BATCH_SIZE="$2"
            shift
            shift
            ;;
        --label_source)
            LABEL_SOURCE="$2"
            shift
            shift
            ;;
        --edge_type)
            EDGE_TYPE="$2"
            shift
            shift
            ;;
        --help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $key"
            show_help
            exit 1
            ;;
    esac
done

# Validate label source
if [ "$LABEL_SOURCE" != "original" ] && [ "$LABEL_SOURCE" != "llm" ]; then
    echo "Error: label_source must be 'original' or 'llm'"
    exit 1
fi

# Extract provider and dataset name for directory structure
PROVIDER=$(echo "$DATASET_NAME" | cut -d'/' -f1)
DATASET_SHORT=$(echo "$DATASET_NAME" | cut -d'/' -f2)

# Check if embeddings directory exists
if [ ! -d "$EMBEDDINGS_DIR" ]; then
    echo "Warning: embeddings directory does not exist: $EMBEDDINGS_DIR"
    echo "Creating directory structure..."
    mkdir -p "$EMBEDDINGS_DIR"
fi

# Check if embeddings directory exists
if [ ! -d "$EMBEDDINGS_DIR" ]; then
    echo "Error: embeddings directory does not exist: $EMBEDDINGS_DIR"
    exit 1
fi

echo "Generating graphs for dataset: $DATASET_NAME"
echo "Embeddings directory: $EMBEDDINGS_DIR"
echo "Batch size: $BATCH_SIZE"
echo "Edge type: $EDGE_TYPE"
echo "Label source: $LABEL_SOURCE"

# Find best LLM model if using LLM labels
if [ "$LABEL_SOURCE" = "llm" ]; then
    echo "Looking for best performing LLM model..."
    
    # Find the latest LLM model directory
    LLM_BASE_DIR="/app/src/Clean_Code/output/finetuned_llms/$PROVIDER"
    
    if [ ! -d "$LLM_BASE_DIR" ]; then
        echo "Error: LLM directory not found: $LLM_BASE_DIR"
        exit 1
    fi
    
    # Find all model directories for this dataset
    MODEL_DIRS=$(find "$LLM_BASE_DIR" -maxdepth 1 -type d -name "${DATASET_SHORT}_*" | sort)
    
    if [ -z "$MODEL_DIRS" ]; then
        echo "Error: No LLM model directories found for dataset $DATASET_SHORT"
        exit 1
    fi
    
    # Find the best model based on f1 score in test set
    BEST_F1=0
    BEST_MODEL=""
    
    for DIR in $MODEL_DIRS; do
        # Check the latest epoch's test classification report
        LATEST_REPORT=$(find "$DIR" -name "classification_report_test_epoch*.json" | sort -V | tail -n 1)
        
        if [ -f "$LATEST_REPORT" ]; then
            # Extract f1 score from weighted avg section using Python to parse JSON
            F1_SCORE=$(python3 -c "import json; f=open('$LATEST_REPORT'); data=json.load(f); print(data['weighted avg']['f1-score'] if 'weighted avg' in data else data['macro avg']['f1-score'] if 'macro avg' in data else 0); f.close()")
            
            # If F1 score is found and is a valid number
            if [[ ! -z "$F1_SCORE" && "$F1_SCORE" =~ ^[0-9.]+$ ]]; then
                echo "Found F1 score $F1_SCORE for model $DIR"
                
                # Compare using Python
                if python3 -c "exit(0 if float('$F1_SCORE') > float('$BEST_F1') else 1)"; then
                    BEST_F1=$F1_SCORE
                    BEST_MODEL=$DIR
                fi
            fi
        fi
    done
    
    if [ -z "$BEST_MODEL" ]; then
        echo "Error: Could not determine best model"
        exit 1
    fi
    
    echo "Best model found: $(basename "$BEST_MODEL") with F1 score: $BEST_F1"
    LLM_PREDICTIONS="$BEST_MODEL/predictions.json"
    
    if [ ! -f "$LLM_PREDICTIONS" ]; then
        echo "Error: Predictions file not found: $LLM_PREDICTIONS"
        exit 1
    fi
    
    echo "Using LLM predictions from: $LLM_PREDICTIONS"
    
    # Run graph processor with LLM predictions
    python -m src.Clean_Code.Graph_Generation.graph_data_processor \
        --dataset_name "$DATASET_NAME" \
        --embeddings_dir "$EMBEDDINGS_DIR" \
        --batch_size "$BATCH_SIZE" \
        --edge_type "$EDGE_TYPE" \
        --label_source "llm" \
        --llm_predictions "$LLM_PREDICTIONS"
else
    # Run graph processor with original labels
    python -m src.Clean_Code.Graph_Generation.graph_data_processor \
        --dataset_name "$DATASET_NAME" \
        --embeddings_dir "$EMBEDDINGS_DIR" \
        --batch_size "$BATCH_SIZE" \
        --edge_type "$EDGE_TYPE" \
        --label_source "original"
fi

# Check if graph generation was successful
if [ $? -eq 0 ]; then
    echo "Graph generation completed successfully"
else
    echo "Error: Graph generation failed"
    exit 1
fi

echo "Done!"
